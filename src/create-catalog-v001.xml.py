#!/usr/bin/env python3

# Portions of this file contributed by NIST are governed by the following
# statement:
#
# This software was developed at the National Institute of Standards
# and Technology by employees of the Federal Government in the course
# of their official duties. Pursuant to title 17 Section 105 of the
# United States Code this software is not subject to copyright
# protection and is in the public domain. NIST assumes no
# responsibility whatsoever for its use by other parties, and makes
# no guarantees, expressed or implied, about its quality,
# reliability, or any other characteristic.
#
# We would appreciate acknowledgement if the software is used.

__version__ = "0.0.3"

import argparse
import csv
import logging
import os
import xml.etree.ElementTree as ETree
from pathlib import Path
from typing import Dict, List, Set, Tuple
from xml.dom import minidom

from rdflib import OWL, RDF, Graph, URIRef

NS_OWL = OWL
NS_RDF = RDF


# XML prolog, as generated by Protege.
XML_VERSION_INFO = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>'


def main() -> None:
    parser = argparse.ArgumentParser()
    parser.add_argument("--debug", action="store_true")
    # "x" mode - exclusive creation.
    # https://docs.python.org/3/library/functions.html#open
    parser.add_argument("out_xml", type=argparse.FileType("x"))
    parser.add_argument(
        "roots_tsv",
        help="A two-column file, with column 1 being a string prefix in-common to ontology prefix IRIs, and column 2 being a file system directory relative to top_srcdir that is the root directory housing that ontology's files.",
        type=argparse.FileType("r"),
    )
    parser.add_argument("top_srcdir")
    parser.add_argument("in_ttl")
    args = parser.parse_args()

    logging.basicConfig(level=logging.DEBUG if args.debug else logging.INFO)

    top_srcdir_abspath = Path(args.top_srcdir).resolve()
    if not top_srcdir_abspath.exists():
        raise FileNotFoundError(args.top_srcdir)
    if not top_srcdir_abspath.is_dir():
        raise NotADirectoryError(args.top_srcdir)

    focus_graph_abspath = Path(args.in_ttl).resolve()
    focus_graph = Graph()
    focus_graph.parse(str(focus_graph_abspath))
    focus_graph_srcdir_abspath = focus_graph_abspath.parent
    focus_graph_relpath = focus_graph_abspath.relative_to(top_srcdir_abspath)
    logging.debug(focus_graph_relpath)

    top_srcdir_relpath = Path(os.path.relpath(top_srcdir_abspath, focus_graph_abspath))
    logging.debug(top_srcdir_relpath)

    logging.debug(os.path.commonpath([top_srcdir_abspath, focus_graph_abspath]))

    # Determine sole focus ontology IRI.  Fail if there is not exactly 1 found.
    n_focus_ontologies: Set[URIRef] = set()
    for triple in focus_graph.triples((None, NS_RDF.type, NS_OWL.Ontology)):
        if isinstance(triple[0], URIRef):
            n_focus_ontologies.add(triple[0])
    if len(n_focus_ontologies) < 1:
        raise ValueError("Found no focus ontology IRI.")
    if len(n_focus_ontologies) > 1:
        # TODO - Add --focus-iri flag?
        raise NotImplementedError("Found multiple ontology IRIs to use as focus.")
    n_focus_ontology: URIRef = sorted(n_focus_ontologies)[0]

    # Read TSV to get domain prefixes' housing directories.
    ontology_string_prefix_to_domain_directory: Dict[str, Path] = dict()
    reader = csv.reader(args.roots_tsv, delimiter="\t")
    for row in reader:
        ontology_string_prefix = row[0]
        domain_directory_str = row[1].replace("${top_srcdir}", str(top_srcdir_abspath))
        domain_directory = Path(domain_directory_str)
        if not domain_directory.exists():
            raise FileNotFoundError(domain_directory_str)
        if not domain_directory.is_dir():
            raise NotADirectoryError(domain_directory_str)
        ontology_string_prefix_to_domain_directory[
            ontology_string_prefix
        ] = domain_directory
    logging.debug(ontology_string_prefix_to_domain_directory)

    # Walk domain directories to associate ontology reference IRIs with backing files, and to build imports graph.
    # Definition, possibly specialized to just this script:
    # An ontology reference IRI is either an ontology IRI or a versionIRI of an ontology.
    imports_graph = Graph()
    n_ontology_reference_to_backing_file: Dict[URIRef, Path] = dict()
    for domain_directory in ontology_string_prefix_to_domain_directory.values():
        for dirpath, dirnames, filenames in os.walk(str(domain_directory)):
            for filename in filenames:
                # Skip build files (syntax normalization checks).
                if filename.startswith("."):
                    continue
                # Restrict to Turtle files.
                if not filename.endswith(".ttl"):
                    continue
                dirpath_path = Path(dirpath)
                graph_filepath = dirpath_path / filename
                tmp_graph = Graph()
                tmp_graph.parse(str(graph_filepath))
                for triple in tmp_graph.triples((None, NS_RDF.type, NS_OWL.Ontology)):
                    assert isinstance(triple[0], URIRef)
                    n_ontology_reference_to_backing_file[triple[0]] = graph_filepath
                    imports_graph.add(triple)
                for triple in tmp_graph.triples((None, NS_OWL.imports, None)):
                    imports_graph.add(triple)
                for triple in tmp_graph.triples((None, NS_OWL.versionIRI, None)):
                    assert isinstance(triple[2], URIRef)
                    n_ontology_reference_to_backing_file[triple[2]] = graph_filepath
                    imports_graph.add(triple)
    logging.debug(len(imports_graph))
    logging.debug(n_ontology_reference_to_backing_file)

    unversioned_iri_imports_graph = Graph()
    query = """\
SELECT ?nImportingOntology ?nImportedOntology
WHERE {
  ?nImportingOntology
    owl:imports ?nVersionIRI ;
    .
  ?nImportedOntology
    owl:versionIRI ?nVersionIRI ;
    .
}
"""
    for versioned_iri_result in imports_graph.query(query):
        unversioned_iri_imports_graph.add(
            (versioned_iri_result[0], NS_OWL.imports, versioned_iri_result[1])
        )
    query = """\
SELECT ?nImportingOntology ?nImportedOntology
WHERE {
  ?nImportingOntology
    owl:imports ?nImportedOntology ;
    .
  ?nImportedOntology
    a owl:Ontology ;
    .
}
"""
    for unversioned_iri_result in imports_graph.query(query):
        unversioned_iri_imports_graph.add(
            (unversioned_iri_result[0], NS_OWL.imports, unversioned_iri_result[1])
        )
    logging.debug(len(unversioned_iri_imports_graph))

    n_imported_iri_to_relative_backing_path: Dict[URIRef, Path] = dict()

    def _map_n_ontology_reference(n_ontology_reference: URIRef) -> None:
        # Handle base case - node visited.
        if n_ontology_reference in n_imported_iri_to_relative_backing_path:
            return
        n_imported_iris: Set[URIRef] = set()
        for triple in imports_graph.triples(
            (n_ontology_reference, NS_OWL.imports, None)
        ):
            assert isinstance(triple[2], URIRef)
            n_imported_iri = triple[2]
            n_imported_iris.add(n_imported_iri)
            imported_iri_backing_file_abspath = n_ontology_reference_to_backing_file[
                n_imported_iri
            ]
            imported_iri_backing_file_relpath = Path(
                os.path.relpath(
                    imported_iri_backing_file_abspath, focus_graph_srcdir_abspath
                )
            )
            n_imported_iri_to_relative_backing_path[
                n_imported_iri
            ] = imported_iri_backing_file_relpath
        # Recurse.
        for n_imported_iri in n_imported_iris:
            _map_n_ontology_reference(n_imported_iri)

    _map_n_ontology_reference(n_focus_ontology)
    logging.debug(n_imported_iri_to_relative_backing_path)

    # Create catalog XML tree.
    xml_root = ETree.Element("catalog")

    # Mimic attributes for the root node from exemplar generated by Protege.
    xml_root.attrib = {
        "prefer": "public",
        "xmlns": "urn:oasis:names:tc:entity:xmlns:xml:catalog",
    }
    # Sort catalog entries by relative file path, again mimicing Protege behavior.
    catalog_entries: List[Tuple[str, str]] = sorted(
        [
            (
                str(n_imported_iri_to_relative_backing_path[n_ontology_reference]),
                str(n_ontology_reference),
            )
            for n_ontology_reference in n_imported_iri_to_relative_backing_path.keys()
        ]
    )
    for catalog_entry in catalog_entries:
        e_child = ETree.SubElement(xml_root, "uri")
        e_child.attrib = {
            "id": "User Entered Import Resolution",
            "uri": catalog_entry[0],
            "name": catalog_entry[1],
        }
    xml_tree_string = minidom.parseString(
        ETree.tostring(xml_root, encoding="utf-8", method="xml").decode("utf-8")
    ).toprettyxml(indent="    ")
    args.out_xml.write(f"{XML_VERSION_INFO}\n")
    args.out_xml.write(f"{xml_tree_string[23:]}")

    return


if __name__ == "__main__":
    main()
